# Support Vector Machines

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache=TRUE)
reticulate::use_condaenv("r-sjsdm", required = TRUE)
#reticulate::use_python("/home/maxpichler/miniconda3/envs/r-sjsdm/bin/python", required = TRUE)
```

The support vector machine (SVM) algorithm estimates hyper-planes to separate our response species. In the following we use the 'e1071' package which supports a variety of different SVM algorithms (@e1071) (Python: 'scikit-learn' (@scikit-learn), Julia: 'MLJ' (@anthony_blaom_2019_3541506)).

## Classification

::: panel-tabset
### R

```{r, message=FALSE}
library(e1071)
X = scale(iris[,1:4])
Y = iris$Species

sv = svm(X, Y, probability = TRUE) 
summary(sv)
```

Make predictions (class probabilities):

```{r, message=FALSE}
head(attr(predict(sv, newdata = X, probability = TRUE), "probabilities"), n = 3)
```

### Python

```{python, warning=FALSE, message=FALSE}
from sklearn import svm
from sklearn import datasets
from sklearn.preprocessing import scale
iris = datasets.load_iris()
X = scale(iris.data)
Y = iris.target

model = svm.SVC(probability=True).fit(X, Y)

# Make predictions (class probabilities):

model.predict_proba(X)[0:10,:]

```

### Julia

```{julia}
import StatsBase;
using MLJ;
SVM_classifier = @load NuSVC pkg=LIBSVM;
using RDatasets;
using StatsBase;
using DataFrames;
```

```{julia}
iris = dataset("datasets", "iris");
X = mapcols(StatsBase.zscore, iris[:, 1:4]);
Y = iris[:, 5];

```

Models:

```{julia}
model = fit!(machine(SVM_classifier(), X, Y))
```

Predictions:

```{julia}
MLJ.predict(model, X)[1:5]
```
:::

## Regression

::: panel-tabset
### R

```{r, message=FALSE}
library(e1071)
X = scale(iris[,2:4])
Y = iris[,1]

sv = svm(X, Y) 
summary(sv)
```

Make predictions (class probabilities):

```{r, message=FALSE}
head(predict(sv, newdata = X), n = 3)
```

### Python

```{python, warning=FALSE, message=FALSE}
from sklearn import svm
from sklearn import datasets
from sklearn.preprocessing import scale
iris = datasets.load_iris()
data = iris.data
X = scale(data[:,1:4])
Y = data[:,0]

model = svm.SVR().fit(X, Y)

# Make predictions:

model.predict(X)[0:10]

```

### Julia

```{julia}
import StatsBase;
using MLJ;
SVM_regressor =  @load NuSVR pkg=LIBSVM;
using RDatasets;
using DataFrames;
```

```{julia}
iris = dataset("datasets", "iris");
X = mapcols(StatsBase.zscore, iris[:, 2:4]);
Y = iris[:, 1];
```

Model:

```{julia}
model = fit!(machine(SVM_regressor(), X, Y))
```

Predictions:

```{julia}
MLJ.predict(model, X)[1:5]
```
:::
